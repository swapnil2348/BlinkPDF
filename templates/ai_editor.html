{% extends "base.html" %}
{% block seo_title %}AI PDF Editor - BlinkPDF{% endblock %}
{% block seo_desc %}Edit, sign, OCR and modify PDFs online for free{% endblock %}

{% block content %}

<style>
  .tool-btn {
    padding: 6px 14px;
    border-radius: 6px;
    background: #f3f4f6;
    font-size: 14px;
    border: 1px solid #e5e7eb;
  }

  .tool-btn:hover { background: #e5e7eb; }

  .tool-btn.active {
    background: #7c3aed;
    color: white;
  }

  #pdf-canvas {
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
</style>

<section class="max-w-7xl mx-auto px-4 py-8">

  <h1 class="text-3xl font-bold mb-4">AI PDF Editor (PRO)</h1>

  <!-- Upload -->
  <div class="bg-white p-6 rounded-xl shadow border mb-6">
    <form id="uploadForm" class="flex flex-col sm:flex-row gap-4">
      <input
        type="file"
        id="pdfUpload"
        accept="application/pdf"
        required
        class="border p-2 rounded flex-1"
      >

      <button
        type="button"
        id="uploadBtn"
        class="bg-violet-600 text-white px-6 py-2 rounded hover:bg-violet-700 w-full sm:w-auto"
      >
        Upload & Start
      </button>
    </form>

    <p id="status" class="text-sm mt-3 text-violet-600 font-semibold"></p>
  </div>

  <div class="grid grid-cols-12 gap-4">

    <!-- Thumbnails -->
    <div class="col-span-12 md:col-span-2 bg-white border rounded-xl p-3 overflow-y-auto max-h-[600px]" id="thumbs">
      <p class="text-xs text-gray-400 text-center">No file loaded</p>
    </div>

    <!-- Main editor -->
    <div class="col-span-12 md:col-span-10 space-y-3">

      <div class="bg-white p-3 rounded-xl shadow border flex gap-2 flex-wrap items-center">

        <button class="tool-btn" onclick="rewriteSelectedText()">ü§ñ AI Rewrite</button>
        <button class="tool-btn" onclick="openFindReplace()">üîÅ Find & Replace</button>
        <button class="tool-btn" onclick="enableDeleteMode()">‚ùå Delete text</button>
        <button class="tool-btn" onclick="addStickyNote()">üí¨ Comment</button>
        <button class="tool-btn" onclick="openParagraphEditor()">¬∂ Paragraph</button>
        <button class="tool-btn" onclick="startSignature()">‚úç Sign</button>
        <button class="tool-btn" onclick="runOCR()">üîé OCR</button>

        <button class="tool-btn" onclick="zoomOut()">üîç -</button>
        <button class="tool-btn" onclick="zoomIn()">üîé +</button>
        <button class="tool-btn" onclick="toggleCropMode()">‚úÇ Crop</button>

        <button class="tool-btn" onclick="undo()">‚Ü© Undo</button>
        <button class="tool-btn" onclick="redo()">‚Ü™ Redo</button>

        <button
          class="tool-btn ml-auto"
          style="background:#7c3aed;color:white;"
          onclick="saveFullPDF()"
        >
          üíæ Save FULL PDF
        </button>
      </div>

      <div class="flex items-center justify-between bg-white p-3 rounded-xl shadow border text-sm">
        <div>
          <button class="tool-btn" onclick="prevPage()">‚¨Ö Prev</button>
          <button class="tool-btn" onclick="nextPage()">Next ‚û°</button>
        </div>
        <div>
          Page <span id="pageNum">-</span> / <span id="pageCount">-</span>
        </div>
      </div>

      <div class="bg-gray-100 p-2 md:p-4 rounded-xl overflow-scroll touch-pan" style="max-height:75vh;">
        <div style="min-width:100%; display:flex; justify-content:center;">
          <div class="bg-white shadow-xl p-4 rounded-xl min-w-[800px]">
            <canvas id="pdf-canvas"></canvas>
          </div>
        </div>
      </div>

    </div>
  </div>

</section>

{% endblock %}

{% block scripts %}

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js";</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>

<script>
// ================= PRO TEXT ENGINE LEVEL 2 =================
let pageStates = {};              // Stores JSON for each page
let autoSaveInterval = null;      // Autosave timer
let currentFont = "Times New Roman";
let currentFontSize = 16;
let realEdits = [];
let currentScale = 1;

let pdfDoc = null;
let currentPage = 1;
let baseWidth = 800;

let fabricCanvas = new fabric.Canvas("pdf-canvas");
let ctx = document.getElementById("pdf-canvas").getContext("2d");
let originalPdfBytes = null;

async function loadPDF() {
  const fileInput = document.getElementById("pdfUpload");
  if (!fileInput.files[0]) {
    alert("Please select a PDF first");
    return;
  }

  const arrayBuffer = await fileInput.files[0].arrayBuffer();
  originalPdfBytes = arrayBuffer;

  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  pdfDoc = await loadingTask.promise;

  document.getElementById("pageCount").innerText = pdfDoc.numPages;
  showPage(1);
  generateThumbs();
}

document.getElementById("uploadBtn").addEventListener("click", async function(){

  const file = document.getElementById("pdfUpload").files[0];
  if(!file){ alert("Select a PDF"); return; }

  const status = document.getElementById("status");
  status.innerText="‚è≥ Loading PDF...";

  const reader = new FileReader();
  reader.onload = async function(e){
    const bytes = new Uint8Array(e.target.result);
    pdfDoc = await pdfjsLib.getDocument({data:bytes}).promise;

    currentPage=1;
    document.getElementById("pageCount").innerText = pdfDoc.numPages;

    await showPage(currentPage);
    generateThumbs();

    status.innerText="‚úÖ PDF loaded";
  }

  reader.readAsArrayBuffer(file);

  const formData=new FormData();
  formData.append("file",file);
  const res=await fetch("/ai/upload-pdf",{method:"POST",body:formData});
  const data=await res.json();
  if(data.success){ window.serverPDF=data.filename; }
});


async function showPage(n){

  // remember current page
  currentPage = n;
  document.getElementById("pageNum").innerText = n;

  const page = await pdfDoc.getPage(n);
  const unscaled = page.getViewport({scale:1});
  const scale = baseWidth / unscaled.width;
  currentScale = scale;

  const viewport = page.getViewport({scale});

  const canvas = document.getElementById("pdf-canvas");
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  // reset fabric canvas for this page
  fabricCanvas.clear();
  fabricCanvas.setWidth(viewport.width);
  fabricCanvas.setHeight(viewport.height);

  // draw PDF page into the plain canvas
  await page.render({ canvasContext: ctx, viewport }).promise;

  // use rendered page as non-selectable background
  const bg = canvas.toDataURL();
  fabric.Image.fromURL(bg, img => {
    img.selectable = false;
    img.evented = false;
    img.scaleToWidth(fabricCanvas.width);
    img.scaleToHeight(fabricCanvas.height);
    fabricCanvas.setBackgroundImage(
      img,
      fabricCanvas.renderAll.bind(fabricCanvas)
    );
  });

  // extract text items for smart editing
  const text = await page.getTextContent();

  text.items.forEach((t, idx) => {
    if (!t.str.trim()) return;
	const cleanedText = t.str.replace(/\s+/g," ").trim();
    if(cleanedText.length <= 1) return;


    // PDF.js transform ‚Üí canvas coords
    const tx = pdfjsLib.Util.transform(viewport.transform, t.transform);
    const x = tx[4];
    const yBaseline = tx[5];

    // pdf.js gives height in PDF units; convert to canvas
    const fontSize = t.height * scale;

    // fabric.Textbox uses top-left, pdf.js y is baseline -> shift up
    const top = yBaseline - fontSize;

    // width fallback if pdf.js doesn't give t.width
    const approxWidth = (t.width || (t.str.length * fontSize * 0.6)) * scale;

    // white box that hides the original printed text
    const eraseBox = new fabric.Rect({
      left: x,
      top: top,
      width: approxWidth + 4,
      height: fontSize + 4,
      fill: "#ffffff",
      selectable: false,
      evented: false
    });

    const obj = new fabric.Textbox(t.str, {
      left: x,
      top: top,
      fontSize: fontSize,
      fill: "#000",
      width: approxWidth + 20,
      backgroundColor: "transparent",
      splitByGrapheme: true,
      lockScalingFlip: true
    });

    // metadata used by real save engine
    obj.pageIndex = n;                 // 1-based page index
    obj.pdfRect = {
      x: x / scale,
      y: top / scale,
      width: (t.width || approxWidth / scale),
      height: t.height
    };
    obj.fontSizePdf = fontSize;        // keep original font size
    obj._rectId = `${n}-${idx}`;       // stable id for this text run

    fabricCanvas.add(eraseBox);
    fabricCanvas.add(obj);
  });

  fabricCanvas.renderAll();
}
// Restore previous state if page was edited before
if (pageStates[n]) {
  fabricCanvas.loadFromJSON(pageStates[n], () => {
    fabricCanvas.renderAll();
  });
}

/* when user finishes editing a text box ‚Üí queue real PDF edit */
fabricCanvas.on("text:editing:exited", (e) => {
  const obj = e.target;
  if (!obj || !obj.pdfRect || obj.pageIndex == null) return;

  // remove any previous edit for same block
  realEdits = realEdits.filter(
    ed => !(ed.page === obj.pageIndex && ed.rectId === obj._rectId)
  );

  realEdits.push({
    page: obj.pageIndex,                 // 1-based page
    rectId: obj._rectId,                 // internal id (safe extra)
    rect: obj.pdfRect,                   // {x,y,width,height} in PDF units
    newText: obj.text,
    fontSize: obj.fontSizePdf || obj.fontSize || 12
  });

  document.getElementById("status").innerText =
    "‚úè Text will be saved in PDF";
});


async function saveFullPDF() {
  if (!originalPdfBytes) {
    alert("No PDF loaded");
    return;
  }

  const pdfDocLib = await PDFLib.PDFDocument.load(originalPdfBytes);
  const pages = pdfDocLib.getPages();

  const font = await pdfDocLib.embedFont(PDFLib.StandardFonts.Helvetica);

  // Means: loop through ALL pages
  for (let i = 0; i < pages.length; i++) {

    if (i + 1 !== currentPage) continue; 
    const page = pages[i];

    const { width, height } = page.getSize();

    // Loop every Fabric.js text object
    fabricCanvas.getObjects().forEach(obj => {

      if (obj.type === "textbox" || obj.type === "i-text") {

        const scale = height / fabricCanvas.height;

        const x = obj.left * scale;
        const y = height - (obj.top * scale) - (obj.fontSize * scale);

        page.drawText(obj.text, {
          x: x,
          y: y,
          size: obj.fontSize * scale,
          font: font,
          color: PDFLib.rgb(0, 0, 0),
          maxWidth: obj.width * scale,
          lineHeight: obj.fontSize * scale * 1.3
        });

      }
    });

  }

  const finalBytes = await pdfDocLib.save();

  const blob = new Blob([finalBytes], { type: "application/pdf" });

  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "BlinkPDF_PRO_EDITED.pdf";
  link.click();
}

// Learn font & size automatically
fabricCanvas.on("selection:created", function (e) {
  if (e.selected && e.selected[0] && e.selected[0].type.includes("text")) {
    currentFont = e.selected[0].fontFamily || currentFont;
    currentFontSize = e.selected[0].fontSize || currentFontSize;
  }
});

fabricCanvas.on("selection:updated", function (e) {
  if (e.selected && e.selected[0] && e.selected[0].type.includes("text")) {
    currentFont = e.selected[0].fontFamily || currentFont;
    currentFontSize = e.selected[0].fontSize || currentFontSize;
  }
});

function prevPage(){
  if(!pdfDoc) return;

  pageStates[currentPage] = fabricCanvas.toJSON();

  if (currentPage <= 1) return;
  showPage(currentPage - 1);
}

function nextPage(){
  if(!pdfDoc) return;

  pageStates[currentPage] = fabricCanvas.toJSON();

  if (currentPage >= pdfDoc.numPages) return;
  showPage(currentPage + 1);
}

function startAutoSave(){
  if(autoSaveInterval) clearInterval(autoSaveInterval);

  autoSaveInterval = setInterval(() => {
    if(pdfDoc){
      pageStates[currentPage] = fabricCanvas.toJSON();
      console.log("Auto saved page", currentPage);
    }
  }, 3000);
}
fabricCanvas.on("text:changed", function(e){
  const obj = e.target;
  if(!obj || !obj.text) return;

  const errors = obj.text.split(" ").filter(word => word.length > 20);

  if(errors.length > 0){
    obj.set("underline", true);
    obj.set("fill", "red");
  }else{
    obj.set("underline", false);
    obj.set("fill", "#000");
  }

  fabricCanvas.renderAll();
});
fabricCanvas.on("mouse:dblclick", function (opt) {
  if (opt.target && (opt.target.type === "textbox" || opt.target.type === "i-text")) {
    opt.target.enterEditing();
    opt.target.selectAll();
  }
});
</script>

{% endblock %}
